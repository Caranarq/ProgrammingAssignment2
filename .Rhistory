a
find.package("devtools")
library(devtools)
find_rtools()
library(devtools)
find_rtools()
find.package("devtools")
library(devtools)
exit
exit
above <- function(x, n) {
use <- x<n
x[use]
}
above
above(10)
above <- function(x, n) {
use <- x < n
x[use]
}
above(10)
above <- function(x, n) {
use <- x > n
x[use]
}
above <- function(x, n) {
use <- x > n
x[use]
}
x <- 1:20
above(x,30)
above(x,10)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
above
above()
above(x,)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i])
}
means
}
columnmean(airquality)
columnmean <- function(y) {
nc <- ncol(y)## how many columns does this dataframe have? This calculates the number of columns
means <- numeric(nc) ## Create a numeric vector that equals the number of columns
for(i in 1:nc) { ##an integer vector, starts in 1 and end in nc
means[i] <- mean(y[, i]) ## for each value of i, calculates the mean of y[ ,i]
}
means #Return the means
}
columnmeans(airquality)
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) { ##Same function as above, but removes NA values
nc <- ncol(y)## how many columns does this dataframe have? This calculates the number of columns
means <- numeric(nc) ## Create a numeric vector that equals the number of columns
for(i in 1:nc) { ##an integer vector, starts in 1 and end in nc
means[i] <- mean(y[, i], na.rm = removeNA) ## for each value of i, calculates the mean of y[ ,i]; also remove NA values
}
means #Return the means
}
columnmean(airquality)
f <- function(a, b) {
a2
}
f(2)
f <- function(a, b) {
a^2
}
f(2)
f <- function(a, b) {
print(a)
print(b) ## R will look for 'a' as first argument to print, then will look for 'b' as second argument to print. If it does not find any, it will return an error
}
f(10, 20)
f(10, )
f(, 20)
f(, 20)
f(b = 15, a = 654)
myplot <- function(x, y, type = "1", ...) {
plot(x, y, type = type, ...)
}
myplot <- function(x, y, type = "l", ...) {
plot(x, y, type = type, ...)
}
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
Pow(2)
make.power(3)
cube <- make.power(3)
square <- make.power(2)
cube
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
cube(3)
square(2)
ls(environment(cube))
get("n", environment(cube))
y <- 10
f <- function(x) {
y <- 2
y^2 + g(x)
}
g <- function(x) {
x*y
}
f(3)
ls()
rm(ls())
rm(ls[1])
rm(list(ls[1])
)
list(ls())
rm(list(ls()))
list = ls()
list
rm(list)
ls()
rm(above)
rm(list = ls())
list = ls()
list
x <- list = ls()
rm(list)
cube <- function(x, n) {
x^3
}
cubr(3)
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
h <- function(x, y = NULL, d = 3L) {
z <- cbind(x, d)
if(!is.null(y))
z <- z + y
else
z <- z + f
g <- x + y / z
if(d == 3L)
return(g)
g <- g + 10
g
}
h
rm(list = ls())
setwd("F:/Shared/Learning/R Programming/Week 3/Prog2
")
getwd()
setwd("F:/Shared
")
setwd("F:/Shared")
setwd("F:\Shared")
setwd("F:/Shared/")
setwd("F:/Shared/Learning/R Programming/Week 3/Prog2/
")
setwd("learning")
setwd("R Preogramming")
setwd("R Programming")
setwd("Week 3")
setwd("Prog2")
getwd()
?solve
?NULL
?makeVector
makeVectmakeVector <- function(x = numeric()) { #creates a function called "makeVector", which takes one argument and coerces it to be numeric. Everything that follows is part of this function
m <- NULL #initializes the variable "m" as a NULL. That is to say, it clears any values from "m", so you don't have to worry about some leftover value getting introduced into your function.
set <- function(y) { #creates a sub-function called "set", which takes an argument "y".
x <<- y # is part of the "set" sub-function, and sets "x" to "y" within the whole function "makeVector", not just the sub-function.
m <<- NULL # also part of "set", initializes "m". This makes sense because you are telling the function that you made a new vector (which likely has a different mean, a.k.a. a different "m").
}
get <- function() x # creates a sub-function called "get", which reports the value of x. I believe that the "x" comes after the "function()" because this way, the function takes no arguments, it just prints x.
setmean <- function(mean) m <<- mean # creates a sub-function called "setmean".
getmean <- function() m #
list(set = set, get = get, #
setmean = setmean, #
getmean = getmean) #
}
makeVector <- function(x = numeric()) { #creates a function called "makeVector", which takes one argument and coerces it to be numeric. Everything that follows is part of this function
m <- NULL #initializes the variable "m" as a NULL. That is to say, it clears any values from "m", so you don't have to worry about some leftover value getting introduced into your function.
set <- function(y) { #creates a sub-function called "set", which takes an argument "y".
x <<- y # is part of the "set" sub-function, and sets "x" to "y" within the whole function "makeVector", not just the sub-function.
m <<- NULL # also part of "set", initializes "m". This makes sense because you are telling the function that you made a new vector (which likely has a different mean, a.k.a. a different "m").
}
get <- function() x # creates a sub-function called "get", which reports the value of x. I believe that the "x" comes after the "function()" because this way, the function takes no arguments, it just prints x.
setmean <- function(mean) m <<- mean # creates a sub-function called "setmean".
getmean <- function() m #
list(set = set, get = get, #
setmean = setmean, #
getmean = getmean) #
}
rm(makeVectmakeVector)
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
test <- 1:10
makevector(test)
makeVector(test)
testt <- makeVector(x)
ls.str(environment(testt$get))
cachemean(testt)
testt <- makeVector(test)
cachemean(testt)
ls.str(environment(testt$get))
?function
()
